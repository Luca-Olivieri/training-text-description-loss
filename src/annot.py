"""
This module provides utilities for interacting with Google Drive and Google Docs to automate the process of creating annotation documents with images and prompts.
It includes functions for uploading images, inserting content into Google Docs, and extracting table data from documents.
"""

from config import GDRIVE_ANNOT_IMGS_PATH
from data import get_many_answer_gt, get_many_answer_pr, get_one_answer_pr
from path import CONFIG_PATH, LOCAL_ANNOT_IMGS_PATH
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from google.oauth2 import service_account
from typing import List, Tuple, Optional, TypeVar
from pathlib import Path
import re
import time

ImageMediaMetadata = TypeVar

from prompter import PromptBuilder
from config import *

SCOPES = ["https://www.googleapis.com/auth/documents",
          "https://www.googleapis.com/auth/drive.file",       # Allows uploading files
          'https://www.googleapis.com/auth/drive'
]

SERVICE_ACCOUNT_FILE = 'gen-lang-client-0021813944-33af2e4f8465.json'

INTRO = """What follows is one of the variants for prompts used so far for the VLM differencing. The variant I chose is the one which is the most human-readable.

In the first section (this one), the full prompt is presented so I avoid pasting it for every section, while the following sections contain the queries to annotate. Each section contains a single query, along with two examples of answers generated by the VLM in two different settings."""

creds = service_account.Credentials.from_service_account_file(
        CONFIG_PATH/SERVICE_ACCOUNT_FILE, scopes=SCOPES)
docs_service = build('docs', 'v1', credentials=creds)
drive_service = build('drive', 'v3', credentials=creds)

def get_image_from_gdrive(
        file_id: str,
        fields: str = "id, name, imageMediaMetadata"
):
    """
    Fetches metadata for an image file from Google Drive.

    Args:
        file_id: The ID of the file in Google Drive.
        fields: The fields to retrieve from the file metadata.

    Returns:
        The file metadata as returned by the Drive API.
    """
    file = drive_service.files().get(fileId=file_id, fields=fields).execute()
    return file

def list_file_ids_in_folder(
        folder_id: str
) -> list[Tuple[str, str, ImageMediaMetadata]]:
    """
    Fetches file IDs, names, and metadata for all files in a Google Drive folder, sorted by file name.

    Args:
        folder_id: The ID of the folder in Google Drive.

    Returns:
        List of tuples (name, id, imageMediaMetadata) for each file.
    """
    query = f"'{folder_id}' in parents and trashed = false"
    results = drive_service.files().list(
        q=query,
        fields="files(id, name, imageMediaMetadata)",
        pageSize=1000
    ).execute()
    files = results.get('files', [])    
    # Sort the list by file name in ascending order

    def extract_number(name: str) -> int:
        match = re.search(r'(\d+)$', name)
        return int(match.group(1)) if match else -1
    
    sorted_files = sorted([(f['name'], f['id'], f['imageMediaMetadata']) for f in files], key=lambda x: extract_number(x[0]))
    return sorted_files

def upload_local_image_to_gdrive(
        local_root_path: Path,
        gdrive_dir_id: str,
        name: str
) -> str:
    """
    Uploads a local image to a Google Drive folder and makes it publicly viewable.

    Args:
        local_root_path: The local directory containing the image.
        gdrive_dir_id: The ID of the Google Drive folder.
        name: The name to assign to the uploaded image (without extension).

    Returns:
        The file metadata of the uploaded image.
    """
    file_metadata = {
        'name': name,
        'parents': [gdrive_dir_id],
    }
    media = MediaFileUpload(local_root_path / f"{name}.png", mimetype='image/png')  # change mimetype if needed
    file = drive_service.files().create(
        body=file_metadata,
        media_body=media,
        fields='id'
    ).execute()

    # Make image publicly viewable
    drive_service.permissions().create(fileId=file['id'], body={'type': 'anyone', 'role': 'reader'}).execute()

    return file

def upload_local_images_to_gdrive(
        img_idxs: list[int],
        gdrive_dir_id: str
) -> list[str]:
    """
    Uploads multiple local images to a Google Drive folder.

    Args:
        img_idxs: List of image indices to upload.
        gdrive_dir_id: The ID of the Google Drive folder.

    Returns:
        List of file IDs for the uploaded images.
    """
    file_ids = []
    for img_idx in img_idxs:
        name = f"annot_image_{img_idx}"
        file = upload_local_image_to_gdrive(LOCAL_ANNOT_IMGS_PATH, gdrive_dir_id, name)
        file_ids.append(file['id'])
    return file_ids

def delete_file_from_gdrive(
        file_id: str
) -> None:
    """
    Deletes a file from Google Drive by its file ID.

    Args:
        file_id: The ID of the file to delete.
    """
    drive_service.files().delete(fileId=file_id).execute()

def append_page_break_to_gdoc(
        gdoc_id: str
) -> None:
    """
    Appends a page break to the end of a Google Doc.

    Args:
        gdoc_id: The ID of the Google Doc.
    """
    # Get the current document to get the end index
    doc = docs_service.documents().get(documentId=gdoc_id).execute()

    # Get the end index of the document
    end_index = doc['body']['content'][-1]['endIndex']

    # Define the page break request at the end
    page_break_request = {
        'insertPageBreak': {
            'location': {'index': end_index - 1}  # Insert the page break just before the final newline
        }
    }

    # Execute the request to insert the page break
    docs_service.documents().batchUpdate(documentId=gdoc_id, body={'requests': [page_break_request]}).execute()

def append_text_to_gdoc(
        gdoc_id: str,
        text: str,
        paragraph_style: str
) -> None:
    """
    Appends styled text to a Google Doc.

    Args:
        gdoc_id: The ID of the Google Doc.
        text: The text to insert.
        paragraph_style: The named style type for the paragraph.
    """

    par_styles = ["NORMAL_TEXT", "TITLE", "SUBTITLE", "HEADING_1", "HEADING_2", "HEADING_3", "HEADING_4", "HEADING_5", "HEADING_6"]

    if paragraph_style not in par_styles:
        raise ValueError(f"{paragraph_style} is an invalid paragraph style. Must be one of {par_styles}.")

    # Get the document to find the current end
    doc = docs_service.documents().get(documentId=gdoc_id).execute()
    end_index = doc['body']['content'][-1]['endIndex']

    start_index = end_index - 1  # -1 to overwrite the last newline
    end_index = start_index + len(text)

    # Insert text
    insert_request = {
        'insertText': {
            'location': {'index': start_index},
            'text': text
        }
    }

    style_request = {
        'updateParagraphStyle': {
            'range': {
                'startIndex': start_index,
                'endIndex': end_index
            },
            'paragraphStyle': {
                'namedStyleType': paragraph_style,
                'alignment': 'JUSTIFIED'
            },
            'fields': 'namedStyleType,alignment'
        }
    }

    docs_service.documents().batchUpdate(documentId=gdoc_id, body={'requests': [insert_request, style_request]}).execute()

def append_bulleted_list_to_gdoc(
        gdoc_id: str,
        text_list: list
) -> None:
    """
    Appends a bulleted (numbered) list to a Google Doc.

    Args:
        gdoc_id: The ID of the Google Doc.
        text_list: List of strings to include as bullet points.
    """
    # Get the document to find the current end
    doc = docs_service.documents().get(documentId=gdoc_id).execute()
    end_index = doc['body']['content'][-1]['endIndex']

    text = "\n".join(text_list)

    start_index = end_index - 1  # -1 to overwrite the last newline
    end_index = start_index + len(text)

    # Insert text
    insert_request = {
        'insertText': {
            'location': {'index': start_index},
            'text': text
        }
    }

    style_request = {
        'updateParagraphStyle': {
            'range': {
                'startIndex': start_index,
                'endIndex': end_index
            },
            'paragraphStyle': {
                'namedStyleType': "NORMAL_TEXT",
            },
            'fields': 'namedStyleType,alignment'
        }
    }

    # Create a bullet point for the inserted text
    bullet_request = {
        'createParagraphBullets': {
            'range': {
                'startIndex': start_index,
                'endIndex': end_index
            },
            'bulletPreset': 'NUMBERED_DECIMAL_ALPHA_ROMAN'
        }
    }
    
    # Append a newline to end the list and remove bullets from it
    newline_insert = {'insertText': {'location': {'index': end_index}, 'text': '\n'}}
    remove_bullets = {'deleteParagraphBullets': {'range': {'startIndex': end_index+1, 'endIndex': end_index+2}}}

    # Execute the requests to insert text and create the bullet point
    docs_service.documents().batchUpdate(documentId=gdoc_id, body={'requests': [insert_request, style_request, bullet_request, newline_insert, remove_bullets]}).execute()

    # Ensure the next text is inserted after the current text
    end_index += 1  # Insert a newline between text items

def append_image_to_gdoc(
        gdoc_id: str,
        image_id: str,
        image_size: Optional[Tuple] = None
) -> None:
    """
    Appends an image from Google Drive to a Google Doc.

    Args:
        gdoc_id: The ID of the Google Doc.
        image_id: The ID of the image in Google Drive.
        image_size: Optional (height, width) in points. If None, uses default width.
    """
    
    image_metadata = get_image_from_gdrive(image_id)["imageMediaMetadata"]
    aspect_ratio = image_metadata["height"] / image_metadata["width"]

    if image_size is None:
        image_width_pt = 468 # default Google Docs full page width in points (8.5" page - 1" margins × 2)
        image_height_pt = image_width_pt * aspect_ratio
    else:
        image_height_pt, image_width_pt = image_size

    # Get current end of the document
    doc = docs_service.documents().get(documentId=gdoc_id).execute()
    end_index = doc['body']['content'][-1]['endIndex']

    # Insert image request
    image_request = {
        'insertInlineImage': {
            'location': {'index': end_index - 1},
            'uri': f"https://drive.google.com/uc?id={image_id}",
            'objectSize': {
                'height': {'magnitude': image_height_pt, 'unit': 'PT'},
                'width': {'magnitude': image_width_pt, 'unit': 'PT'}
            }
        }
    }

    # Send batch update
    docs_service.documents().batchUpdate(documentId=gdoc_id, body={'requests': [image_request]}).execute()

    append_text_to_gdoc(gdoc_id, "\n", "NORMAL_TEXT")

def append_table_to_gdoc(
        gdoc_id: str,
        num_rows: int,
        num_columns: int
) -> None:
    """
    Appends a table to a Google Doc.

    Args:
        gdoc_id: The ID of the Google Doc.
        num_rows: Number of rows in the table.
        num_columns: Number of columns in the table.
    """
    # Get the current document to get the end index
    doc = docs_service.documents().get(documentId=gdoc_id).execute()

    # Get the end index of the document
    end_index = doc['body']['content'][-1]['endIndex']

    # Define the table request at the end
    table_request = {
        'insertTable': {
            'location': {'index': end_index - 1},  # Insert before the final newline
            'rows': num_rows,
            'columns': num_columns
        }
    }

    # Execute the request to insert the table
    docs_service.documents().batchUpdate(documentId=gdoc_id, body={'requests': [table_request]}).execute()

def write_intro_to_gdoc(
        gdoc_id: str,
        intro: str,
        name: str
) -> None:
    """
    Writes the introduction section to a Google Doc, including a title and page break.

    Args:
        gdoc_id: The ID of the Google Doc.
        intro: The introduction text.
        name: The name to include in the title.
    """
    append_text_to_gdoc(gdoc_id, f"Annotation Form ({name})\n", "TITLE")
    append_text_to_gdoc(gdoc_id, intro, "NORMAL_TEXT")
    append_page_break_to_gdoc(gdoc_id)

def write_prompt_to_gdoc(
        gdoc_id: str,
        prompt: List,
        img_ids_sizes: List[Tuple]
) -> None:
    """
    Writes a prompt (text and images) to a Google Doc, followed by a page break.

    Args:
        gdoc_id: The ID of the Google Doc.
        prompt: List of prompt elements (strings or image placeholders).
        img_ids_sizes: List of (image_id, image_size) tuples for images in the prompt.
    """
    img_counter: int = 0
    for piece in prompt:
        if isinstance(piece, str):
            append_text_to_gdoc(gdoc_id, f"{piece}\n", "NORMAL_TEXT")
        else:
            img_id, img_size = img_ids_sizes[img_counter]
            append_image_to_gdoc(gdoc_id, img_id, img_size)
            img_counter += 1
    append_page_break_to_gdoc(gdoc_id)

def write_query_prompt(
        gdoc_id: str,
        query_n: int,
        img_id: str,
        example_answers: List[str]
) -> None:
    """
    Writes a single prompt in the Google document of a certain recipient.

    Args:
        gdoc_id: The ID of the Google Doc.
        query_n: The query number for the internal enumeration.
        img_id: The image ID in Google Drive.
        example_answers: The example answers to provide for assistance.
    """
    append_text_to_gdoc(gdoc_id, f"Query id. {query_n}\n", "TITLE")
    append_image_to_gdoc(gdoc_id, img_id)
    append_text_to_gdoc(gdoc_id, f"Your annotation:", "SUBTITLE")
    append_table_to_gdoc(gdoc_id, num_rows=1, num_columns=1)
    append_text_to_gdoc(gdoc_id, f"Some VLM example answers:\n", "SUBTITLE")
    append_bulleted_list_to_gdoc(gdoc_id, [f"\"{a.strip()}\"" for a in example_answers])
    append_page_break_to_gdoc(gdoc_id)

def write_annot_doc(
        gdoc_id: str,
        recipient: str,
        query_idxs: List[int],
        promptBuilder: PromptBuilder
) -> None:
    """
    Writes prompts in the Google document of a certain recipient.

    Args:
        gdoc_id: The ID of the Google Doc.
        recipient: The person to which the document is given.
        query_idxs: The indices of the images to include in the prompts.
        promptBuilder: The PromptBuilder instance.
    """
    write_intro_to_gdoc(gdoc_id, INTRO, recipient)
    inference_prompt = promptBuilder.build_inference_prompt(0)
    cmap_size_pt = (100*5, 157*5)
    file_objects = list_file_ids_in_folder(GDRIVE_ANNOT_IMGS_PATH)
    cmap_object, img_objects = file_objects[0], file_objects[1:] # the first image in the dir should be the color map
    _, cmap_id, _ = cmap_object
    _, img_ids, _ = zip(*img_objects)
    write_prompt_to_gdoc(gdoc_id, inference_prompt[:-5], [(cmap_id, cmap_size_pt), *[(img_ids[sup_set_idx], None) for sup_set_idx in promptBuilder.sup_set_idxs]])
    for i, query_idx in enumerate(query_idxs):
        time.sleep(5)
        ex_1 = get_one_answer_pr(promptBuilder.by_model, promptBuilder.split_by, f"examples_for_annots/ConcatMasks_Ovr_Hz", query_idx)[query_idx]
        ex_2 = get_one_answer_pr(promptBuilder.by_model, promptBuilder.split_by, f"examples_for_annots/SepMasks_Ovr", query_idx)[query_idx]
        ex_3 = get_one_answer_pr(promptBuilder.by_model, promptBuilder.split_by, f"examples_for_annots/ArrayMasks_Imgs_Ovr", query_idx)[query_idx]
        write_query_prompt(gdoc_id, query_idx, img_ids[query_idx], [ex_1, ex_2, ex_3])

def extract_table_content_from_gdoc(
        gdoc_id: str
) -> List[str]:
    """
    Extracts the textual content from all tables in a Google Doc, assuming each table contains a single cell.

    Args:
        gdoc_id: The ID of the Google Doc.

    Returns:
        A list of strings, where each string is the content of a table.
    """
    extracted_contents = []
    doc = docs_service.documents().get(documentId=gdoc_id).execute()
    
    # Iterate through the document's structural elements
    for element in doc.get('body', {}).get('content', []):
        # Check if the element is a table
        if 'table' in element:
            table = element['table']
            # Assuming each table has only one row and one cell
            # You might need to add more robust checks if table structures vary
            for row in table.get('tableRows', []):
                for cell in row.get('tableCells', []):
                    # Extract text from the cell's content
                    for content_element in cell.get('content', []):
                        if 'paragraph' in content_element:
                            for run in content_element['paragraph'].get('elements', []):
                                if 'textRun' in run:
                                    extracted_contents.append(run['textRun'].get('content', '').strip())
    return extracted_contents

def main() -> None:
    pass

if __name__ == '__main__':
    main()
